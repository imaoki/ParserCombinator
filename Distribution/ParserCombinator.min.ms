/*! Â© 2022 imaoki | MIT License | https://github.com/imaoki */;(local hasMetRequirements;fn hasMetRequirements = (isStruct ::std and isProperty ::std #StructName and classOf ::std.StructName == MAXScriptFunction and ::std.StructName() == #StandardStruct;);if not hasMetRequirements() do (local fileClass = DotNetClass "System.IO.File";local pathClass = DotNetClass "System.IO.Path";local currentDir = pathClass.GetDirectoryName (getSourceFileName());local standardFile = currentDir + @"\Standard.min.ms";if fileClass.Exists standardFile do fileIn standardFile;);if not hasMetRequirements() do (format "[error]Requirement not met.\n";););global parserCombinatorDefinitionPool = Dictionary #String;::parserCombinatorDefinitionPool[@"Model\AstNode.ms"] = struct AstNodeStruct (public Type = #Unknown,public Value,public fn StructName = #AstNodeStruct,private fn dumpValue v indent out delimiter:"" = (if this.isAstNode v then (v.Dump indent:indent out:out delimiter:delimiter;);else (case classOf v of ((Array): (format "#(\n" to:out;for i = 1 to v.Count do (if not this.isAstNode v[i] do (format "%  " indent to:out;);local delimiterChar = if i == v.Count then "" else ",";this.dumpValue v[i] (indent + "  ") out delimiter:delimiterChar;);format "%)%\n" indent delimiter to:out;);(String): (local valueText = ::std.StringUtility.EscapeBackslash v;format "\"%\"%\n" valueText delimiter to:out;);default: (local valueText = ::std.StringUtility.ToPascalCase v;valueText = ::std.StringUtility.EscapeBackslash valueText;format "%%\n" valueText delimiter to:out;);););ok;),private fn isAstNode obj = (isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == #AstNodeStruct;),public fn Dump indent:"" out:listener delimiter:"" = (format "%AstNodeStruct" indent to:out;format " Type:%" (::std.StringUtility.ToPascalCase this.Type) to:out;if this.isAstNode this.Value then (format " Value:(\n" to:out;this.dumpValue this.Value (indent + "  ") out delimiter:"";format "%)%\n" indent delimiter to:out;);else (format " Value:" to:out;this.dumpValue this.Value indent out delimiter:delimiter;);ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = isProperty obj #Type and classOf obj.Type == Name and obj.Type == this.Type and isProperty obj #Value;if isEqualProperties do (local ov = obj.Value;local tv = this.Value;isEqualProperties = case classOf this.Value of ((Array): (local result = ov.Count == tv.Count;for i = 1 to tv.Count while result do (local t1 = tv[i];local o1 = ov[i];if isProperty t1 #Equals and classOf t1.Equals == MAXScriptFunction then (result = t1.Equals o1;);else (result = o1 == t1;););result;);default: (if isProperty tv #Equals and classOf tv.Equals == MAXScriptFunction then (tv.Equals ov;);else (ov == tv;););););isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Model\Cache.ms"] = struct CacheStruct (private data = Dictionary #String,public fn Clear = (free this.data;this.data = Dictionary #String;ok;),public fn Read parser start = (local result = DataPair Hit:false Cache:undefined;local key = this.generateKey parser start;result.Hit = hasDictValue this.data key;if result.Hit do (result.Cache = this.data[key];);result;),public fn Write parser start end result = (local key = this.generateKey parser start;this.data[key] = DataPair End:end Value:result;ok;),private fn generateKey parser start = (with printAllElements true parser as String + ":" + start as String;),public fn StructName = #CacheStruct,public fn Dump indent:"" out:listener = (format "%CacheStruct\n" indent to:out;format "%  data:%\n" indent this.data.Count to:out;for key in this.data.Keys do (local keyText = ::std.StringUtility.EscapeBackslash key;local valueText = this.data[key];if classOf v == String then (valueText = ::std.StringUtility.EscapeBackslash valueText;);else (valueText = ::std.StringUtility.ToPascalCase valueText;valueText = ::std.StringUtility.EscapeBackslash valueText;);format "%    [\"%\"]:\"%\"\n" indent keyText valueText to:out;);ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Model\Error.ms"] = struct ErrorStruct (public Expected = "",public LineNumber = 0,public LineText = "",public Offset = -1,public OffsetChar = "",public fn Clear = (this.Expected = "";this.LineNumber = 0;this.LineText = "";this.Offset = -1;this.OffsetChar = "";ok;),public fn StructName = #ErrorStruct,public fn Dump indent:"" out:listener = (format "%ErrorStruct\n" indent to:out;format "%  Expected:\"%\"\n" indent (::std.StringUtility.EscapeBackslash this.Expected) to:out;format "%  LineNumber:%\n" indent this.LineNumber to:out;format "%  LineText:\"%\"\n" indent (::std.StringUtility.EscapeBackslash this.LineText) to:out;format "%  Offset:%\n" indent this.Offset to:out;format "%  OffsetChar:\"%\"\n" indent (::std.StringUtility.EscapeBackslash this.OffsetChar) to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Model\Failure.ms"] = struct FailureStruct (public fn StructName = #FailureStruct,public fn Dump indent:"" out:listener = (format "%FailureStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Model\NotCollect.ms"] = struct NotCollectStruct (public fn StructName = #NotCollectStruct,public fn Dump indent:"" out:listener = (format "%NotCollectStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Model\Context.ms"] = struct ContextStruct (public _CP1_,private cache,private lastError,private lineRanges = #(),private ss = StringStream "",public fn EOS = (::eof this.ss;),public fn GetLastError = (this.lastError;),public fn GetLineNumber offset = (local lineNumber = 0;for i = 1 to this.lineRanges.Count while lineNumber == 0 do (local range = this.lineRanges[i];if range.Start <= offset and offset <= range.End do (lineNumber = i;););lineNumber;),public fn GetOffset = (::filePos this.ss;),public fn LogError errorOffset expected = (if errorOffset > this.lastError.Offset do (local offset = this.GetOffset();this.Seek errorOffset;local offsetChar = this.Read 1;this.Seek offset;local lineNumber = this.GetLineNumber errorOffset;local lineText = this.getLineText lineNumber;this.lastError.Expected = expected;this.lastError.LineNumber = lineNumber;this.lastError.LineText = lineText;this.lastError.Offset = errorOffset;this.lastError.OffsetChar = offsetChar;);ok;),public fn PrintDebugInfo parserName startOffset result = (local resultText = with printAllElements true result as String;resultText = ::std.StringUtility.EscapeBackslash resultText;if classOf result == String do (resultText = "\"" + resultText + "\"";);format "% offset:[%-%] error:(position:% line:% expected:%) result:%\n" parserName startOffset (this.GetOffset()) this.lastError.Offset this.lastError.LineNumber this.lastError.Expected resultText;ok;),public fn PrintError result = (local errorType = undefined;case classOf result of ((::FailureStruct): errorType = "error";default: (if this.lastError.Offset >= 0 do (errorType = "warning";);););if classOf errorType == String do (format "[syntax %]at \"%\" in position:% line:%, expected:%, in line:%\n" errorType (::std.StringUtility.EscapeBackslash this.lastError.OffsetChar) this.lastError.Offset this.lastError.LineNumber this.lastError.Expected (::std.StringUtility.EscapeBackslash this.lastError.LineText););ok;),public fn Read count = (::readChars this.ss count errorAtEOF:false;),public fn ReadCache parser = (this.cache.Read parser (this.GetOffset());),public fn Seek offset = (::seek this.ss offset;this.GetOffset();),public fn SetStream input = (this.initialize();this.ss = StringStream (replace_CRLF_with_LF input);this.setLineRanges();this.Seek 0;ok;),public fn SOS = (this.GetOffset() == 0;),public fn WriteCache parser start end result = (this.cache.Write parser start end result;),private fn getLineText lineNumber = (local lineText = "";local lineCount = this.lineRanges.Count;if lineCount > 0 and 1 <= lineNumber and lineNumber <= lineCount do (local offset = this.GetOffset();local start = this.lineRanges[lineNumber].Start;local end = this.lineRanges[lineNumber].End;this.Seek start;lineText = this.Read (end - start + 1);this.Seek offset;);lineText;),private fn initialize = (if isStruct this.cache do (this.cache.Clear(););if isStruct this.lastError do (this.lastError.Clear(););this.lineRanges = #();this.ss = StringStream "";ok;),private fn setLineRanges = (this.Seek 0;local lineEnds = #(0);while not eof this.ss do (if skipToString this.ss "\n" != undefined do (append lineEnds (this.GetOffset());););appendIfUnique lineEnds (this.GetOffset());if lineEnds.Count > 0 do (lineEnds[lineEnds.Count] += 1;);this.lineRanges = for i = 2 to lineEnds.Count collect (DataPair Start:lineEnds[i - 1] End:(lineEnds[i] - 1););ok;),public fn StructName = #ContextStruct,public fn Dump indent:"" out:listener = (format "%ContextStruct\n" indent to:out;format "%  Offset:%\n" indent (this.GetOffset()) to:out;format "%  cache:\n" indent to:out;this.cache.Dump indent:(indent + "    ") out:out;format "%  lastError:\n" indent to:out;this.lastError.Dump indent:(indent + "    ") out:out;format "%  lineRanges:%\n" indent this.lineRanges.Count to:out;local offset = this.GetOffset();for i = 1 to this.lineRanges.Count do (local start = this.lineRanges[i].Start;local end = this.lineRanges[i].End;this.Seek start;local startChar = this.Read 1;startChar = ::std.StringUtility.EscapeBackslash startChar;this.Seek end;local endChar = this.Read 1;endChar = ::std.StringUtility.EscapeBackslash endChar;this.Seek start;local lineText = this.Read (end - start + 1);lineText = ::std.StringUtility.EscapeBackslash lineText;format "%    [%-%]:Start:\"%\" End:\"%\" Line:\"%\"\n" indent start end startChar endChar lineText to:out;);this.Seek offset;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (if classOf this._CP1_ == String do (this.SetStream this._CP1_;);this.cache = (::parserCombinatorDefinitionPool[@"Model\Cache.ms"])();this.lastError = (::parserCombinatorDefinitionPool[@"Model\Error.ms"])();););::parserCombinatorDefinitionPool[@"Parser\And.ms"] = struct AndStruct (public Parsers = #(),public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local offset = copy startOffset;local result = ::FailureStruct();local parserCount = this.Parsers.Count;local isSuccessful = parserCount > 0;for i = 1 to parserCount - 1 while isSuccessful do (isSuccessful = classOf (this.Parsers[i].Parse context) != ::FailureStruct;context.Seek offset;);if isSuccessful do (result = this.Parsers[parserCount].Parse context;);if this.Debug do context.PrintDebugInfo "AndStruct" startOffset result;result;),public fn StructName = #AndStruct,public fn Dump indent:"" out:listener = (format "%AndStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  Parsers:%\n" indent this.Parsers.Count to:out;for i = 1 to this.Parsers.Count do (format "%    [%]\n" indent i to:out;this.Parsers[i].Dump indent:(indent + "      ") out:out;);ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\AnyChar.ms"] = struct AnyCharStruct (public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local result = ::FailureStruct();if not context.EOS() do (result = context.Read 1;);if this.Debug do context.PrintDebugInfo "AnyCharStruct" startOffset result;result;),public fn StructName = #AnyCharStruct,public fn Dump indent:"" out:listener = (format "%AnyCharStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\Choice.ms"] = struct ChoiceStruct (public Parsers = #(),public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local offset = copy startOffset;local result = ::FailureStruct();for p in this.Parsers while classOf result == ::FailureStruct do (result = p.Parse context;if classOf result == ::FailureStruct do (context.Seek offset;););if this.Debug do context.PrintDebugInfo "ChoiceStruct" startOffset result;result;),public fn StructName = #ChoiceStruct,public fn Dump indent:"" out:listener = (format "%ChoiceStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  Parsers:%\n" indent this.Parsers.Count to:out;for i = 1 to this.Parsers.Count do (format "%    [%]\n" indent i to:out;this.Parsers[i].Dump indent:(indent + "      ") out:out;);ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\Delay.ms"] = struct DelayStruct (public Callback,public Debug = false,public fn Parse context = ((this.Callback()).Parse context;),public fn StructName = #DelayStruct,public fn Dump indent:"" out:listener = (format "%DelayStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  Callback:%\n" indent (classOf this.Callback) to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\EOS.ms"] = struct EOSStruct (public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local result = ::FailureStruct();if context.EOS() do (result = ::NotCollectStruct(););if this.Debug do context.PrintDebugInfo "EOSStruct" startOffset result;result;),public fn StructName = #EOSStruct,public fn Dump indent:"" out:listener = (format "%EOSStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\Expect.ms"] = struct ExpectStruct (public Parser,public Expected = "",public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local offset = copy startOffset;local result = this.Parser.Parse context;if classOf result == ::FailureStruct do (context.LogError offset this.Expected;);if this.Debug do context.PrintDebugInfo "ExpectStruct" startOffset result;result;),public fn StructName = #ExpectStruct,public fn Dump indent:"" out:listener = (format "%ExpectStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  Expected:\"%\"\n" indent this.Expected to:out;format "%  Parser:\n" indent to:out;this.Parser.Dump indent:(indent + "    ") out:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\IsNot.ms"] = struct IsNotStruct (public Parser,public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local offset = copy startOffset;local result = this.Parser.Parse context;if classOf result == ::FailureStruct then (context.Seek offset;result = ::NotCollectStruct(););else (result = ::FailureStruct(););if this.Debug do context.PrintDebugInfo "IsNotStruct" startOffset result;result;),public fn StructName = #IsNotStruct,public fn Dump indent:"" out:listener = (format "%IsNotStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  Parser:\n" indent to:out;this.Parser.Dump indent:(indent + "    ") out:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\Lookahead.ms"] = struct LookaheadStruct (public Parsers = #(),public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local result = ::FailureStruct();local parserCount = this.Parsers.Count;local isSuccessful = parserCount > 1;if isSuccessful do (local offset1 = copy startOffset;result = this.Parsers[1].Parse context;local offset2 = context.GetOffset();isSuccessful = classOf result != ::FailureStruct;for i = 2 to parserCount while isSuccessful do (isSuccessful = classOf (this.Parsers[i].Parse context) != ::FailureStruct;context.Seek offset2;);if not isSuccessful do (result = ::FailureStruct();context.Seek offset1;););if this.Debug do context.PrintDebugInfo "LookaheadStruct" startOffset result;result;),public fn StructName = #LookaheadStruct,public fn Dump indent:"" out:listener = (format "%LookaheadStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  Parsers:%\n" indent this.Parsers.Count to:out;for i = 1 to this.Parsers.Count do (format "%    [%]\n" indent i to:out;this.Parsers[i].Dump indent:(indent + "      ") out:out;);ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\Many.ms"] = struct ManyStruct (public Parser,public MinCount = 0,public MaxCount = 2147483647,public Debug = false,private intMax = 2147483647,public fn Parse context = (local startOffset = context.GetOffset();local result = ::FailureStruct();local isSuccessful = true;local results = for i = 1 to this.MaxCount while not context.EOS() and isSuccessful collect (local offset = context.GetOffset();local parserResult = this.Parser.Parse context;isSuccessful = classOf parserResult != ::FailureStruct;if isSuccessful then (if classOf parserResult == ::NotCollectStruct then (dontCollect;);else (parserResult;););else (context.Seek offset;dontCollect;););if not results.Count < this.MinCount do (result = results;);if this.Debug do context.PrintDebugInfo "ManyStruct" startOffset result;result;),public fn StructName = #ManyStruct,public fn Dump indent:"" out:listener = (format "%ManyStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  MinCount:%\n" indent this.MinCount to:out;format "%  MaxCount:%\n" indent this.MaxCount to:out;format "%  Parser:\n" indent to:out;this.Parser.Dump indent:(indent + "    ") out:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (if this.MaxCount > this.intMax do (this.MaxCount = copy this.intMax;);););::parserCombinatorDefinitionPool[@"Parser\Map.ms"] = struct MapStruct (public Parser,public Callback,public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local result = this.Parser.Parse context;if classOf result != ::FailureStruct and classOf this.Callback == MAXScriptFunction do (result = this.Callback result;);if this.Debug do context.PrintDebugInfo "MapStruct" startOffset result;result;),public fn StructName = #MapStruct,public fn Dump indent:"" out:listener = (format "%MapStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  Callback:%\n" indent (classOf this.Callback) to:out;format "%  Parser:\n" indent to:out;this.Parser.Dump indent:(indent + "    ") out:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\Memoize.ms"] = struct MemoizeStruct (public Parser,public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local result = ::FailureStruct();local cacheData = context.ReadCache this.Parser;if cacheData.Hit then (context.Seek cacheData.Cache.End;result = cacheData.Cache.Value;);else (local startOffset = context.GetOffset();result = this.Parser.Parse context;local endOffset = context.GetOffset();context.WriteCache this.Parser startOffset endOffset result;);if this.Debug do context.PrintDebugInfo "MemoizeStruct" startOffset result;result;),public fn StructName = #MemoizeStruct,public fn Dump indent:"" out:listener = (format "%MemoizeStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  Parser:\n" indent to:out;this.Parser.Dump indent:(indent + "    ") out:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\Option.ms"] = struct OptionStruct (public Parser,public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local offset = copy startOffset;local result = this.Parser.Parse context;if classOf result == ::FailureStruct do (context.Seek offset;result = ::NotCollectStruct(););if this.Debug do context.PrintDebugInfo "OptionStruct" startOffset result;result;),public fn StructName = #OptionStruct,public fn Dump indent:"" out:listener = (format "%OptionStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  Parser:\n" indent to:out;this.Parser.Dump indent:(indent + "    ") out:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\Partial.ms"] = struct PartialStruct (public Callback,public CallbackParameter,public Parser,public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local result = this.Parser.Parse context;if classOf result != ::FailureStruct and classOf this.Callback == MAXScriptFunction do (result = this.Callback this.CallbackParameter result;);if this.Debug do context.PrintDebugInfo "PartialStruct" startOffset result;result;),public fn StructName = #PartialStruct,public fn Dump indent:"" out:listener = (format "%PartialStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  Callback:%\n" indent (classOf this.Callback) to:out;if classOf this.CallbackParameter == String then (format "%  CallbackParameter:%\n" indent (::std.StringUtility.EscapeBackslash this.CallbackParameter) to:out;);else (format "%  CallbackParameter:%\n" indent (::std.StringUtility.ToPascalCase this.CallbackParameter) to:out;);format "%  Parser:\n" indent to:out;this.Parser.Dump indent:(indent + "    ") out:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\Sequence.ms"] = struct SequenceStruct (public Parsers = #(),public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local result = ::FailureStruct();local isSuccessful = true;local results = for p in this.Parsers while isSuccessful collect (local parserResult = p.Parse context;isSuccessful = classOf parserResult != ::FailureStruct;if isSuccessful then (if classOf parserResult == ::NotCollectStruct then (dontCollect;);else (parserResult;););else (dontCollect;););if isSuccessful do (result = results;);if this.Debug do context.PrintDebugInfo "SequenceStruct" startOffset result;result;),public fn StructName = #SequenceStruct,public fn Dump indent:"" out:listener = (format "%SequenceStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  Parsers:%\n" indent this.Parsers.Count to:out;for i = 1 to this.Parsers.Count do (format "%    [%]\n" indent i to:out;this.Parsers[i].Dump indent:(indent + "      ") out:out;);ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\SOS.ms"] = struct SOSStruct (public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local result = ::FailureStruct();if context.SOS() do (result = ::NotCollectStruct(););if this.Debug do context.PrintDebugInfo "SOSStruct" startOffset result;result;),public fn StructName = #SOSStruct,public fn Dump indent:"" out:listener = (format "%SOSStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\Token.ms"] = struct TokenStruct (public Pattern = "",public IgnoreCase = true,public Debug = false,public fn Parse context = (local startOffset = context.GetOffset();local result = ::FailureStruct();local str = context.Read this.Pattern.Count;if (this.IgnoreCase and stricmp str this.Pattern == 0) or (not this.IgnoreCase and str == this.Pattern) do (result = str;);if this.Debug do context.PrintDebugInfo "TokenStruct" startOffset result;result;),public fn StructName = #TokenStruct,public fn Dump indent:"" out:listener = (format "%TokenStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  Pattern:\"%\"\n" indent (::std.StringUtility.EscapeBackslash this.Pattern) to:out;format "%  IgnoreCase:%\n" indent this.IgnoreCase to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::parserCombinatorDefinitionPool[@"Parser\Char.ms"] = struct CharStruct (public Pattern = "",public Except = false,public Debug = false,private anyCharParser,private patternChars = #(),public fn Parse context = (local startOffset = context.GetOffset();local result = ::FailureStruct();local char = this.anyCharParser.Parse context;local isMatch = classOf char == String;if isMatch do (local index = findItem this.patternChars char;isMatch = (this.Except and index == 0) or (not this.Except and index > 0););if isMatch do (result = char;);if this.Debug do context.PrintDebugInfo "CharStruct" startOffset result;result;),public fn StructName = #CharStruct,public fn Dump indent:"" out:listener = (format "%CharStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;format "%  Pattern:\"%\"\n" indent (::std.StringUtility.EscapeBackslash this.Pattern) to:out;format "%  Except:%\n" indent this.Except to:out;format "%  patternChars:#(" indent to:out;for i = 1 to this.patternChars.Count do (format "%\"%\"" (if i == 1 then "" else ", ") (::std.StringUtility.EscapeBackslash this.patternChars[i]) to:out;);format ")\n" to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.anyCharParser = (::parserCombinatorDefinitionPool[@"Parser\AnyChar.ms"])();this.patternChars = ::std.StringUtility.ToCharArray this.Pattern;););::parserCombinatorDefinitionPool[@"Parser\Boundary.ms"] = struct BoundaryStruct (public Debug = false,private charParser,public fn Parse context = (local startOffset = context.GetOffset();local result = ::FailureStruct();if context.SOS() or context.EOS() then (result = ::NotCollectStruct(););else (context.Seek (startOffset - 1);local forward = this.charParser.Parse context;context.Seek startOffset;local backward = this.charParser.Parse context;context.Seek startOffset;if (classOf forward == ::FailureStruct and classOf backward == String) or (classOf forward == String and classOf backward == ::FailureStruct) do (result = ::NotCollectStruct();););if this.Debug do context.PrintDebugInfo "BoundaryStruct" startOffset result;result;),public fn StructName = #BoundaryStruct,public fn Dump indent:"" out:listener = (format "%BoundaryStruct\n" indent to:out;format "%  Debug:%\n" indent this.Debug to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.charParser = (::parserCombinatorDefinitionPool[@"Parser\Char.ms"]) "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789";););struct ParserCombinatorStruct (private andDef,private anyCharDef,private boundaryDef,private charDef,private choiceDef,private contextDef,private delayDef,private eosDef,private expectDef,private isNotDef,private lookaheadDef,private manyDef,private mapDef,private memoizeDef,private optionDef,private partialDef,private sequenceDef,private sosDef,private tokenDef,public fn Alphabet debug:false = (this.Choice #(this.LowerAlphabet debug:debug,this.UpperAlphabet debug:debug;) debug:debug;),public fn AndAlso parsers debug:false = (this.andDef parsers Debug:debug;),public fn AnyChar debug:false = (this.anyCharDef Debug:debug;),public fn Boundary debug:false = (this.boundaryDef Debug:debug;),public fn Char pattern except:false debug:false = (this.charDef pattern except Debug:debug;),public fn Choice parsers debug:false = (this.choiceDef parsers Debug:debug;),public fn Context input = (if classOf input != String do (input = input as String;);this.contextDef input;),public fn Delay callback debug:false = (this.delayDef callback Debug:debug;),public fn Diff parserA parserB debug:false = (this.ItemAt (this.Sequence #(this.IsNot parserB debug:debug,parserA;) debug:debug;) -1 debug:debug;),public fn Digit debug:false = (this.Char "0123456789" debug:debug;),public fn EOS debug:false = (this.eosDef Debug:debug;),public fn Expect parser expected:"" debug:false = (this.expectDef parser expected Debug:debug;),public fn Flatten parser depth:-1 debug:false = (this.Partial this.flattenArray depth parser debug:debug;),public fn Install = (::AstNodeStruct = ::parserCombinatorDefinitionPool[@"Model\AstNode.ms"];::FailureStruct = ::parserCombinatorDefinitionPool[@"Model\Failure.ms"];::NotCollectStruct = ::parserCombinatorDefinitionPool[@"Model\NotCollect.ms"];if isProperty ::startupLoader #RegisterFile do (::startupLoader.RegisterFile (getSourceFileName()););format "[install]::ParserCombinatorStruct\n";ok;),public fn IsNot parser debug:false = (this.isNotDef parser Debug:debug;),public fn ItemAt parser index debug:false = (this.Partial this.arrayItemAt index parser debug:debug;),public fn Join parser separator:"" debug:false = (this.Partial this.joinArray separator parser debug:debug;),public fn List parser separator debug:false = (this.Map (this.Sequence #(parser,this.Many (this.ItemAt (this.Sequence #(separator, parser) debug:debug;) 2 debug:debug;) debug:debug;) debug:debug;) this.cons debug:debug;),public fn Lookahead parsers debug:false = (this.lookaheadDef parsers Debug:debug;),public fn LowerAlphabet debug:false = (this.Char "abcdefghijklmnopqrstuvwxyz" debug:debug;),public fn Many parser minCount:0 maxCount:2147483647 debug:false = (this.manyDef parser minCount maxCount Debug:debug;),public fn Map parser callback debug:false = (this.mapDef parser callback Debug:debug;),public fn Memo parser debug:false = (this.memoizeDef parser Debug:debug;),public fn Option parser debug:false = (this.optionDef parser Debug:debug;),public fn Partial callback callbackParameter parser debug:false = (this.partialDef callback callbackParameter parser Debug:debug;),public fn Sequence parsers debug:false = (this.sequenceDef parsers Debug:debug;),public fn Skip parser debug:false = (this.Map parser this.asNotCollect debug:debug;),public fn SOS debug:false = (this.sosDef Debug:debug;),public fn Token pattern ignoreCase:true debug:false = (this.tokenDef pattern ignoreCase Debug:debug;),public fn Uninstall = (if isProperty ::startupLoader #UnregisterFile do (::startupLoader.UnregisterFile (getSourceFileName()););format "[uninstall]::ParserCombinatorStruct\n";ok;),public fn UpperAlphabet debug:false = (this.Char "ABCDEFGHIJKLMNOPQRSTUVWXYZ" debug:debug;),private fn arrayItemAt index result = (if classOf result == Array and result.Count > 0 and (index < 0 or (1 <= index and index <= result.Count)) then (if index < 0 then (result[result.Count];);else (result[index];););else (::FailureStruct(););),private fn asNotCollect result = (::NotCollectStruct();),private fn cons result = (if classOf result == Array and result.Count == 2 and classOf result[2] == Array then (local results = #(result[1]);for i = 1 to result[2].Count do (append results result[2][i];);results;);else (result;);),private fn flattenArray depth result asString:false d:1 = (if classOf result == Array then (local flattenedResult = #();for v in result do (if classOf v == Array then (if depth < 0 or (0 < depth and d <= depth) then (::join flattenedResult (this.flattenArray depth v asString:asString d:(d + 1);););else (append flattenedResult v;););else (if asString and classOf v != String then (append flattenedResult (v as String););else (append flattenedResult v;);););flattenedResult;);else (result;);),private fn joinArray separator result = (if classOf result == Array then (result = this.flattenArray -1 result asString:true;::std.StringUtility.Join result separator:separator;);else (result;);),private version = "1.1.1",public fn StructName = #ParserCombinatorStruct,public fn Dump indent:"" out:listener = (format "%ParserCombinatorStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),public fn GetVersion = (this.version;),on Create do (this.andDef = ::parserCombinatorDefinitionPool[@"Parser\And.ms"];this.anyCharDef = ::parserCombinatorDefinitionPool[@"Parser\AnyChar.ms"];this.boundaryDef = ::parserCombinatorDefinitionPool[@"Parser\Boundary.ms"];this.charDef = ::parserCombinatorDefinitionPool[@"Parser\Char.ms"];this.choiceDef = ::parserCombinatorDefinitionPool[@"Parser\Choice.ms"];this.contextDef = ::parserCombinatorDefinitionPool[@"Model\Context.ms"];this.delayDef = ::parserCombinatorDefinitionPool[@"Parser\Delay.ms"];this.eosDef = ::parserCombinatorDefinitionPool[@"Parser\Eos.ms"];this.expectDef = ::parserCombinatorDefinitionPool[@"Parser\Expect.ms"];this.isNotDef = ::parserCombinatorDefinitionPool[@"Parser\IsNot.ms"];this.lookaheadDef = ::parserCombinatorDefinitionPool[@"Parser\Lookahead.ms"];this.manyDef = ::parserCombinatorDefinitionPool[@"Parser\Many.ms"];this.mapDef = ::parserCombinatorDefinitionPool[@"Parser\Map.ms"];this.memoizeDef = ::parserCombinatorDefinitionPool[@"Parser\Memoize.ms"];this.optionDef = ::parserCombinatorDefinitionPool[@"Parser\Option.ms"];this.partialDef = ::parserCombinatorDefinitionPool[@"Parser\Partial.ms"];this.sequenceDef = ::parserCombinatorDefinitionPool[@"Parser\Sequence.ms"];this.sosDef = ::parserCombinatorDefinitionPool[@"Parser\SOS.ms"];this.tokenDef = ::parserCombinatorDefinitionPool[@"Parser\Token.ms"];););::ParserCombinatorStruct.Install();::ParserCombinatorStruct
